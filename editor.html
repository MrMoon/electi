<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operation Electi - Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .modal-overlay {
            transition: opacity 0.3s ease;
        }
        .modal-content {
            transition: transform 0.3s ease;
        }
        .sortable-header {
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        .sortable-header .sort-icon {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.3;
        }
        .sortable-header.sort-asc .sort-icon, .sortable-header.sort-desc .sort-icon {
             opacity: 1;
        }
        .editor-tab-btn.active {
            background-color: #3b82f6;
            color: white;
        }
        .file-input-label {
            cursor: pointer;
            display: inline-block;
            padding: 0.5rem 1rem;
            color: white;
            background-color: #4f46e5;
            border-radius: 0.375rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .file-input-label:hover {
            background-color: #4338ca;
        }
        input[type="file"] {
            display: none;
        }
        .editor-table thead tr:nth-child(2) th {
            padding: 0.5rem;
        }
        .editor-table thead input[type="text"] {
            width: 100%;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
        }
        .editor-table input, .editor-table textarea, .editor-table select {
            width: 100%;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            background-color: #f9fafb;
        }
         .editor-table textarea {
            min-height: 60px;
         }
        .team-link, .competition-link {
            font-weight: 500;
            color: #4f46e5;
            cursor: pointer;
            text-decoration: none;
            background: none;
            border: none;
            padding: 0;
        }
        .team-link:hover, .competition-link:hover {
            text-decoration: underline;
        }
        
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        .toast-notification {
            background-color: #2d3748;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            position: relative;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.info { background-color: #2b6cb0; }
        .toast-notification.error { background-color: #c53030; }

        /* Select2 Styles */
        .select2-container--default .select2-selection--multiple {
            border: 1px solid #d1d5db;
            background-color: #f9fafb;
            border-radius: 4px;
        }
        .select2-container .select2-selection--multiple {
            min-height: 38px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-blue-50 text-gray-800">

    <div id="app-container" class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-gray-900">Data Editor</h1>
            <p class="mt-2 text-lg text-gray-600">Manage Competitions, Universities, Teams, and Users.</p>
        </header>

        <!-- Data Management Panel -->
        <div class="bg-white rounded-lg shadow-md p-4 mb-8">
            <div class="flex flex-wrap justify-center items-center gap-x-6 gap-y-4">
                <div class="text-center">
                    <p class="font-medium text-gray-700 text-sm">Go Home</p>
                    <a href="index.html" class="file-input-label bg-gray-600 hover:bg-gray-700 text-sm mt-1">Home Page</a>
                </div>
                <div class="text-center">
                    <p class="font-medium text-gray-700 text-sm">Full Backup (JSON)</p>
                    <button id="downloadDbFullBackupBtn" class="file-input-label bg-purple-600 hover:bg-purple-700 text-sm mt-1 w-full text-center">Download</button>
                </div>
                <div class="text-center">
                    <p class="font-medium text-gray-700 text-sm">Restore Backup (JSON)</p>
                    <label for="jsonFileInput" class="file-input-label bg-red-600 hover:bg-red-700 text-sm mt-1">Restore</label>
                    <input type="file" id="jsonFileInput" accept=".json">
                </div>
            </div>
        </div>
        
        <div id="tabContentEditors">
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="border-b border-gray-200 mb-4">
                    <nav class="flex space-x-1" aria-label="Editor Tabs">
                        <button data-editor="competitions" class="editor-tab-btn active font-medium px-4 py-2 rounded-t-lg">Competitions</button>
                        <button data-editor="universities" class="editor-tab-btn font-medium px-4 py-2 rounded-t-lg text-gray-600">Universities</button>
                        <button data-editor="teams" class="editor-tab-btn font-medium px-4 py-2 rounded-t-lg text-gray-600">Teams</button>
                        <button data-editor="users" class="editor-tab-btn font-medium px-4 py-2 rounded-t-lg text-gray-600">Users</button>
                    </nav>
                </div>

                <div id="editorContainer">
                    <!-- This container will hold the editor sub-tabs and content -->
                </div>
            </div>
        </div>

    </div>

    <!-- Password Modal -->
    <div id="passwordModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-white rounded-lg shadow-xl w-full max-w-sm p-6 relative transform scale-95">
            <h3 id="passwordModalTitle" class="text-lg font-bold mb-4">Enter Password</h3>
            <form id="passwordForm">
                <div class="space-y-4">
                    <div>
                        <label for="passwordField" class="block text-sm font-medium text-gray-700">Password</label>
                        <input type="password" id="passwordField" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required>
                    </div>
                    <div id="confirmPasswordContainer" class="hidden">
                        <label for="confirmPasswordField" class="block text-sm font-medium text-gray-700">Confirm Password</label>
                        <input type="password" id="confirmPasswordField" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
                <div class="flex justify-end gap-4 mt-6">
                    <button type="button" id="passwordCancelBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                    <button type="submit" id="passwordOkBtn" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">OK</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-white rounded-lg shadow-xl w-full max-w-md p-6 relative transform scale-95">
            <h3 id="confirmationModalTitle" class="text-lg font-bold mb-4">Confirm Action</h3>
            <p id="confirmationModalMessage" class="text-gray-700 mb-6">Are you sure?</p>
            <div class="flex justify-end gap-4">
                <button id="confirmCancelBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                <button id="confirmOkBtn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Details Modal (for Teams) -->
    <div id="detailsModal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto p-6 relative transform scale-95">
            <button id="closeModalBtn" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800">
                <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
            <div id="modalContentContainer"></div>
        </div>
    </div>
    
    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE VARIABLES ---
            let userDatabase = []; 
            let teamDatabase = [];
            let competitionDatabase = {};
            let universityDatabase = [];
            
            let editorSortStates = {
                competitions: { key: 'name', direction: 'asc' },
                universities: { key: 'name', direction: 'asc' },
                teams: { key: 'name', direction: 'asc' },
                users: { key: 'handle', direction: 'asc' }
            };
            let editorFilters = {
                competitions: {},
                universities: {},
                teams: {},
                users: {}
            };
            let confirmCallback = null;
            let passwordCallback = null;

            // --- DOM ELEMENT REFERENCES ---
            const appContainer = document.getElementById('app-container');
            const editorContainer = document.getElementById('editorContainer');
            const tabContentEditors = document.getElementById('tabContentEditors');
            
            const jsonFileInput = document.getElementById('jsonFileInput');
            const downloadDbFullBackupBtn = document.getElementById('downloadDbFullBackupBtn');
            const universityDataList = document.createElement('datalist'); // Create in memory
            universityDataList.id = 'university-list';
            document.body.appendChild(universityDataList);
            
            const detailsModal = document.getElementById('detailsModal');
            const modalContentContainer = document.getElementById('modalContentContainer');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const confirmationModal = document.getElementById('confirmationModal');
            const confirmationModalTitle = document.getElementById('confirmationModalTitle');
            const confirmationModalMessage = document.getElementById('confirmationModalMessage');
            const confirmCancelBtn = document.getElementById('confirmCancelBtn');
            const confirmOkBtn = document.getElementById('confirmOkBtn');
            const passwordModal = document.getElementById('passwordModal');
            const passwordModalTitle = document.getElementById('passwordModalTitle');
            const passwordForm = document.getElementById('passwordForm');
            const passwordField = document.getElementById('passwordField');
            const confirmPasswordContainer = document.getElementById('confirmPasswordContainer');
            const confirmPasswordField = document.getElementById('confirmPasswordField');
            const passwordCancelBtn = document.getElementById('passwordCancelBtn');
            const passwordOkBtn = document.getElementById('passwordOkBtn');

            // --- CRYPTOGRAPHY ---
            const textEncoder = new TextEncoder();
            const textDecoder = new TextDecoder();

            function arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return window.btoa(binary);
            }

            function base64ToArrayBuffer(base64) {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes.buffer;
            }

            async function getEncryptionKey(password, salt) {
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw",
                    textEncoder.encode(password),
                    { name: "PBKDF2" },
                    false,
                    ["deriveKey"]
                );
                return window.crypto.subtle.deriveKey(
                    {
                        name: "PBKDF2",
                        salt: salt,
                        iterations: 100000,
                        hash: "SHA-256",
                    },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
            }

            async function encryptData(data, password) {
                try {
                    const salt = window.crypto.getRandomValues(new Uint8Array(16));
                    const iv = window.crypto.getRandomValues(new Uint8Array(12));
                    const key = await getEncryptionKey(password, salt);
                    
                    const encryptedContent = await window.crypto.subtle.encrypt(
                        { name: "AES-GCM", iv: iv },
                        key,
                        textEncoder.encode(data)
                    );

                    return {
                        salt: arrayBufferToBase64(salt),
                        iv: arrayBufferToBase64(iv),
                        data: arrayBufferToBase64(encryptedContent)
                    };
                } catch (error) {
                    console.error("Encryption failed:", error);
                    showToast("Encryption failed. See console for details.", "error");
                    return null;
                }
            }

            async function decryptData(encryptedPayload, password) {
                try {
                    const salt = base64ToArrayBuffer(encryptedPayload.salt);
                    const iv = base64ToArrayBuffer(encryptedPayload.iv);
                    const data = base64ToArrayBuffer(encryptedPayload.data);
                    const key = await getEncryptionKey(password, salt);

                    const decryptedContent = await window.crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: iv },
                        key,
                        data
                    );

                    return textDecoder.decode(decryptedContent);
                } catch (error) {
                    console.error("Decryption failed:", error);
                    // This often happens with a wrong password
                    return null;
                }
            }
            
            // --- DATE HELPERS ---
            function formatMonthYear(dateString) {
                if (!dateString) return 'N/A';
                const date = new Date(dateString);
                return date.toLocaleString('default', { month: 'short', year: 'numeric' });
            }
            
            function formatMMYYYY(dateString) {
                if (!dateString) return 'N/A';
                try {
                    const date = new Date(dateString);
                    date.setDate(date.getDate() + 1);
                    const year = date.getUTCFullYear();
                    const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
                    return `${month}-${year}`;
                } catch (e) {
                    return 'Invalid Date';
                }
            }
            
            function toYYYYMM(dateString) {
                if (!dateString) return '';
                try {
                    const date = new Date(dateString);
                    const year = date.getUTCFullYear();
                    const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
                    return `${year}-${month}`;
                } catch(e) {
                    return '';
                }
            }

            // --- NOTIFICATION / MODAL ---
            function showToast(message, type = 'info', duration = 3000) {
                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = `toast-notification ${type}`;
                toast.textContent = message;
                container.appendChild(toast);

                setTimeout(() => {
                    toast.classList.add('show');
                }, 10);

                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, duration);
            }
            
            function showConfirmationModal(title, message, onConfirm) { 
                confirmationModalTitle.textContent = title; 
                confirmationModalMessage.textContent = message; 
                confirmCallback = onConfirm; 
                confirmationModal.classList.remove('hidden'); 
                setTimeout(() => { 
                    confirmationModal.querySelector('.modal-overlay')?.classList.remove('opacity-0'); 
                    confirmationModal.querySelector('.modal-content')?.classList.remove('scale-95'); 
                }, 10); 
            }
            function hideConfirmationModal() { 
                confirmationModal.querySelector('.modal-overlay')?.classList.add('opacity-0'); 
                confirmationModal.querySelector('.modal-content')?.classList.add('scale-95'); 
                setTimeout(() => { 
                    confirmationModal.classList.add('hidden'); 
                    confirmCallback = null; 
                }, 300); 
            }

            function showPasswordModal(title, showConfirm, onConfirm) {
                passwordModalTitle.textContent = title;
                passwordForm.reset();
                confirmPasswordContainer.style.display = showConfirm ? 'block' : 'none';
                confirmPasswordField.required = showConfirm;
                passwordCallback = onConfirm;
                passwordModal.classList.remove('hidden');
                setTimeout(() => {
                    passwordModal.querySelector('.modal-overlay')?.classList.remove('opacity-0');
                    passwordModal.querySelector('.modal-content')?.classList.remove('scale-95');
                    passwordField.focus();
                }, 10);
            }

            function hidePasswordModal() {
                passwordModal.querySelector('.modal-overlay')?.classList.add('opacity-0');
                passwordModal.querySelector('.modal-content')?.classList.add('scale-95');
                setTimeout(() => {
                    passwordModal.classList.add('hidden');
                    passwordCallback = null;
                }, 300);
            }

            // --- BACKUP & RESTORE ---
            function loadJsonFile(file) {
                if (!file) { showToast('Please select a JSON backup file.', 'error'); return; }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const fileContent = e.target.result;
                    try {
                        const data = JSON.parse(fileContent);
                        // Check if it's an unencrypted or encrypted backup
                        if (data.salt && data.iv && data.data) { // It's an encrypted file
                            showPasswordModal('Enter Decryption Password', false, async (password) => {
                                const decryptedJson = await decryptData(data, password);
                                if (!decryptedJson) {
                                    showToast('Decryption failed. Incorrect password or corrupt file.', 'error');
                                    return;
                                }
                                try {
                                    const decryptedData = JSON.parse(decryptedJson);
                                    loadDataIntoApp(decryptedData, file.name);
                                } catch (err) {
                                    showToast('Failed to parse decrypted data. The file might be corrupt.', 'error');
                                }
                            });
                        } else if (data.users && data.competitions) { // It's a plain JSON backup
                            loadDataIntoApp(data, file.name);
                        } else {
                            throw new Error("Invalid backup file format.");
                        }
                    } catch (error) {
                        showToast(`Error reading file: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            }
            
            function loadDataIntoApp(data, fileName) {
                if (!data.users || !data.competitions || !data.universities || !data.teams) {
                    showToast("Invalid backup file format. Must contain 'users', 'competitions', 'universities', and 'teams' keys.", 'error');
                    return;
                }
                showConfirmationModal('Overwrite Data?', `Loading this backup will overwrite all current data. Are you sure?`, () => {
                    userDatabase = data.users.map(u => ({...u, updatedAt: new Date(u.updatedAt) })) || [];
                    competitionDatabase = data.competitions || {};
                    universityDatabase = data.universities || [];
                    teamDatabase = data.teams || [];
                    renderAll();
                    showToast(`Successfully loaded backup from ${fileName}.`, 'info');
                });
            }
            
            function downloadDbFullBackup() {
                if (userDatabase.length === 0 && Object.keys(competitionDatabase).length === 0 && universityDatabase.length === 0 && teamDatabase.length === 0) {
                    showToast("No data to back up.", "error"); return;
                }

                showPasswordModal('Create Backup Password', true, async (password) => {
                    const backupData = {
                        users: userDatabase,
                        teams: teamDatabase,
                        competitions: competitionDatabase,
                        universities: universityDatabase,
                        createdAt: new Date().toISOString()
                    };
                    const jsonString = JSON.stringify(backupData, null, 2);
                    
                    const encryptedPayload = await encryptData(jsonString, password);
                    if (encryptedPayload) {
                        const encryptedJsonString = JSON.stringify(encryptedPayload, null, 2);
                        downloadFile(encryptedJsonString, `electi_backup_encrypted_${getFormattedDateTimeString()}.json`, 'application/json');
                        showToast("Encrypted backup downloaded successfully.", "info");
                    }
                });
            }

            // --- RENDER LOGIC ---
            function renderAll() {
                renderCurrentEditorView();
                updateAllDatalists();
            }
            
            function updateAllDatalists() {
                populateUniversityDatalist();
            }

            // --- CSV PARSING & UPLOAD HANDLING ---
            function parseCsv(text) {
                const lines = text.trim().split('\n');
                const header = lines[0].split(',').map(h => h.trim());
                const rows = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const row = {};
                    for (let j = 0; j < header.length; j++) {
                        let value = values[j] ? values[j].trim() : '';
                        if (value.startsWith('"') && value.endsWith('"')) {
                            value = value.slice(1, -1).replace(/""/g, '"');
                        }
                        row[header[j]] = value;
                    }
                    rows.push(row);
                }
                return rows;
            }

            function handleFileUpload(file, handler) {
                if (!file) { showToast('Please select a file to upload.', 'error'); return; }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try { handler(e.target.result); } catch (error) { showToast(`Error processing file: ${error.message}`, 'error'); console.error(error); }
                };
                reader.readAsText(file);
            }

            function handleCompetitionUpload(csvText) {
                const newComps = parseCsv(csvText);
                let addedCount = 0;
                newComps.forEach(comp => {
                    const name = comp['Competition Name'];
                    if (name) {
                        competitionDatabase[name] = { 
                            link: comp['Link'] || '', 
                            total: parseInt(comp['Total Participants'], 10) || 0,
                            date: comp['Date (YYYY-MM)'] || null
                        };
                        addedCount++;
                    }
                });
                renderAll();
                showToast(`${addedCount} competitions added or updated.`, 'info');
            }

            function handleUniversityUpload(csvText) {
                const newUnis = csvText.trim().split('\n').map(line => line.split(',')[0].trim()).filter(Boolean);
                let addedCount = 0;
                newUnis.forEach(uni => {
                    if (!universityDatabase.includes(uni)) {
                        universityDatabase.push(uni);
                        addedCount++;
                    }
                });
                universityDatabase.sort();
                renderAll();
                showToast(`${addedCount} new universities added.`, 'info');
            }

            function handleTeamUpload(csvText) {
                const newTeams = parseCsv(csvText);
                let addedCount = 0;
                newTeams.forEach(teamRow => {
                    const name = teamRow['Team Name'];
                    const university = teamRow['University'];
                    const members = teamRow['Members'] ? teamRow['Members'].split(',').map(h => h.trim()) : [];
                    if (name && university) {
                        const existingTeam = teamDatabase.find(t => t.name.toLowerCase() === name.toLowerCase());
                        const teamData = {
                            name, university, members,
                            isActive: teamRow['Is Active'] ? teamRow['Is Active'].toLowerCase() === 'true' : true,
                            createdAt: teamRow['Created At'] || new Date().toISOString(),
                            inactiveAt: teamRow['Inactive At'] || null
                        };

                        if (existingTeam) {
                            existingTeam.university = teamData.university;
                            existingTeam.members = teamData.members;
                            existingTeam.isActive = teamData.isActive;
                            existingTeam.inactiveAt = teamData.inactiveAt;
                        } else {
                            teamData.id = crypto.randomUUID();
                            teamDatabase.push(teamData);
                        }
                        addedCount++;
                    }
                });
                renderAll();
                showToast(`${addedCount} teams added or updated.`, 'info');
            }

            function handleUserUpload(csvText) {
                const newUsers = parseCsv(csvText);
                let addedCount = 0;
                let skippedCount = 0;
                newUsers.forEach(userRow => {
                    const handle = userRow['Handle'];
                    const name = userRow['Name'];
                    if (handle && name) {
                        const existingUser = userDatabase.find(u => u.handle.toLowerCase() === handle.toLowerCase());
                        if (existingUser) {
                            skippedCount++;
                            return; // Skip existing handles
                        }
                        userDatabase.push({
                            handle,
                            name,
                            university: userRow['University'] || '',
                            isTrusted: userRow['Is Trusted'] ? userRow['Is Trusted'].toLowerCase() === 'true' : true,
                            placements: [], // Placements are not imported via this CSV
                            updatedAt: new Date().toISOString()
                        });
                        addedCount++;
                    }
                });
                renderAll();
                showToast(`${addedCount} new users added. ${skippedCount} skipped due to existing handles.`, 'info');
            }
            
            // --- EDITOR RENDERING ---
            function renderCurrentEditorView() {
                const activeTab = document.querySelector('.editor-tab-btn.active')?.dataset.editor;
                if (!activeTab) return;
                
                const editorViews = {
                    competitions: getCompetitionEditorHTML(),
                    universities: getUniversityEditorHTML(),
                    teams: getTeamEditorHTML(),
                    users: getUserEditorHTML()
                };
                editorContainer.innerHTML = editorViews[activeTab];
                renderEditorTable(activeTab);
                attachEditorTableEventListeners(activeTab);
            }

            function getGenericEditorHTML(type, title, headers) {
                const typeCaps = capitalize(type);
                const tableHeaders = headers.map(h => `<th class="p-3 sortable-header" data-sort-key="${h.key}">${h.label} <span class="sort-icon"></span></th>`).join('');
                const filterHeaders = headers.map(h => `<th>${h.filterable ? `<input type="text" data-filter-key="${h.key}" placeholder="Filter...">` : ''}</th>`).join('');

                return `
                    <div id="editorContent${typeCaps}" data-editor-type="${type}">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold">${title}</h2>
                        </div>
                        <div id="${type}EditorView">
                             <div class="flex flex-wrap gap-4 items-center mb-4">
                                <button id="add${typeCaps}RowBtn" class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-700 transition text-sm">Add New ${typeCaps.slice(0,-1)}</button>
                                <button id="deleteSelected${typeCaps}Btn" class="bg-red-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-700 transition text-sm">Delete Selected</button>
                                <div class="flex-grow"></div>
                                <label for="upload${typeCaps}CsvEditor" class="file-input-label bg-blue-600 hover:bg-blue-700 !text-sm !py-2 !px-4">Upload CSV</label>
                                <input type="file" id="upload${typeCaps}CsvEditor" accept=".csv">
                                <button id="download${typeCaps}CsvEditor" class="bg-purple-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-purple-700 transition text-sm">Download CSV</button>
                            </div>
                            <div class="overflow-x-auto border rounded-lg">
                                <table id="${type}EditorTable" class="w-full text-sm text-left text-gray-600 editor-table">
                                    <thead class="bg-gray-100 text-xs text-gray-700 uppercase">
                                        <tr>
                                            <th class="p-2 w-10 text-center"><input type="checkbox" class="select-all-editor-checkbox"></th>
                                            ${tableHeaders}
                                        </tr>
                                        <tr>
                                            <th></th>
                                            ${filterHeaders}
                                        </tr>
                                    </thead>
                                    <tbody></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            }

            function getCompetitionEditorHTML() {
                return getGenericEditorHTML('competitions', 'Competition Editor', [
                    { label: 'Competition Name', key: 'name', filterable: true },
                    { label: 'Date (YYYY-MM)', key: 'date', filterable: true },
                    { label: 'Total Participants', key: 'total', filterable: true },
                    { label: 'Link', key: 'link', filterable: false },
                    { label: 'Actions', key: 'actions', filterable: false }
                ]);
            }

            function getUniversityEditorHTML() {
                return getGenericEditorHTML('universities', 'University Editor', [
                    { label: 'University Name', key: 'name', filterable: true },
                    { label: 'Actions', key: 'actions', filterable: false }
                ]);
            }

            function getTeamEditorHTML() {
                return getGenericEditorHTML('teams', 'Team Editor', [
                    { label: 'Team Name', key: 'name', filterable: true },
                    { label: 'University', key: 'university', filterable: true },
                    { label: 'Members', key: 'members', filterable: false },
                    { label: 'Active', key: 'isActive', filterable: false },
                    { label: 'Created At', key: 'createdAt', filterable: true },
                    { label: 'Inactive At', key: 'inactiveAt', filterable: true },
                    { label: 'Actions', key: 'actions', filterable: false }
                ]);
            }
            
            function getUserEditorHTML() {
                return getGenericEditorHTML('users', 'User Editor', [
                    { label: 'Handle', key: 'handle', filterable: true },
                    { label: 'Name', key: 'name', filterable: true },
                    { label: 'University', key: 'university', filterable: true },
                    { label: 'Trusted', key: 'isTrusted', filterable: false },
                    { label: 'Last Updated', key: 'updatedAt', filterable: true },
                    { label: 'Actions', key: 'actions', filterable: false }
                ]);
            }

            function renderEditorTable(editorType) {
                const table = document.querySelector(`#${editorType}EditorTable`);
                if (!table) return;
                const tableBody = table.querySelector('tbody');
                if (!tableBody) return;
                tableBody.innerHTML = '';
                
                let data;
                switch (editorType) {
                    case 'competitions':
                        data = Object.entries(competitionDatabase).map(([name, d]) => ({ ...d, name }));
                        break;
                    case 'universities':
                        data = universityDatabase.map(name => ({ name }));
                        break;
                    case 'teams':
                        data = [...teamDatabase];
                        break;
                    case 'users':
                        data = [...userDatabase];
                        break;
                }

                const filters = editorFilters[editorType];
                const filteredData = data.filter(item => {
                    return Object.entries(filters).every(([key, value]) => {
                        let itemValue = item[key];
                        if (key === 'createdAt' || key === 'inactiveAt' || key === 'updatedAt') {
                            itemValue = formatMMYYYY(itemValue);
                        }
                        return String(itemValue || '').toLowerCase().includes(value.toLowerCase());
                    });
                });

                const { key, direction } = editorSortStates[editorType];
                filteredData.sort((a, b) => {
                    const valA = a[key] || '';
                    const valB = b[key] || '';
                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                    return 0;
                });

                filteredData.forEach(item => {
                    const row = tableBody.insertRow();
                    let id;
                    switch (editorType) {
                        case 'competitions':
                            id = item.name;
                            row.innerHTML = `
                                <td class="p-2 text-center"><input type="checkbox" class="editor-select-checkbox" data-id="${id}"></td>
                                <td class="p-2" data-key="name">${createCompetitionLink(item.name)}</td>
                                <td class="p-2" data-key="date">${item.date || ''}</td>
                                <td class="p-2" data-key="total">${item.total || ''}</td>
                                <td class="p-2" data-key="link"><a href="${item.link || '#'}" target="_blank" class="text-blue-600 hover:underline">${item.link ? 'Link' : ''}</a></td>
                                <td class="p-2 whitespace-nowrap"><button class="edit-btn text-blue-600 hover:underline">Edit</button> <button class="delete-btn text-red-600 hover:underline ml-2">Delete</button></td>`;
                            break;
                        case 'universities':
                            id = item.name;
                            row.innerHTML = `
                                <td class="p-2 text-center"><input type="checkbox" class="editor-select-checkbox" data-id="${id}"></td>
                                <td class="p-2" data-key="name">${item.name}</td>
                                <td class="p-2 whitespace-nowrap"><button class="edit-btn text-blue-600 hover:underline">Edit</button> <button class="delete-btn text-red-600 hover:underline ml-2">Delete</button></td>`;
                            break;
                        case 'teams':
                            id = item.id;
                            row.innerHTML = `
                                <td class="p-2 text-center"><input type="checkbox" class="editor-select-checkbox" data-id="${id}"></td>
                                <td class="p-2" data-key="name">${createTeamLink(item.name, item.id)}</td>
                                <td class="p-2" data-key="university">${item.university}</td>
                                <td class="p-2" data-key="members">
                                    <div class="space-y-1">${item.members.map(m => `<div>${createUserLink(m)}</div>`).join('')}</div>
                                </td>
                                <td class="p-2" data-key="isActive"><input type="checkbox" ${item.isActive ? 'checked' : ''} disabled></td>
                                <td class="p-2" data-key="createdAt">${formatMMYYYY(item.createdAt)}</td>
                                <td class="p-2" data-key="inactiveAt">${formatMMYYYY(item.inactiveAt)}</td>
                                <td class="p-2 whitespace-nowrap"><button class="edit-btn text-blue-600 hover:underline">Edit</button> <button class="delete-btn text-red-600 hover:underline ml-2">Delete</button></td>`;
                            break;
                        case 'users':
                            id = item.handle;
                            row.innerHTML = `
                                <td class="p-2 text-center"><input type="checkbox" class="editor-select-checkbox" data-id="${id}"></td>
                                <td class="p-2" data-key="handle">${item.handle}</td>
                                <td class="p-2" data-key="name">${item.name}</td>
                                <td class="p-2" data-key="university">${item.university || ''}</td>
                                <td class="p-2" data-key="isTrusted"><input type="checkbox" ${item.isTrusted ? 'checked' : ''} disabled></td>
                                <td class="p-2" data-key="updatedAt">${formatMMYYYY(item.updatedAt)}</td>
                                <td class="p-2 whitespace-nowrap"><button class="edit-btn text-blue-600 hover:underline">Edit</button> <button class="delete-btn text-red-600 hover:underline ml-2">Delete</button></td>`;
                            break;
                    }
                    row.dataset.id = id;
                });
                updateEditorSortIndicators(editorType);
                updateSelectAllState(table);
            }
            
            function addEditorTableRow(editorType) {
                const tableBody = document.querySelector(`#${editorType}EditorTable tbody`);
                if (!tableBody) return;
                const row = tableBody.insertRow(0);
                row.dataset.id = `new_${Date.now()}`;
                let cells = '';
                switch (editorType) {
                    case 'competitions':
                        cells = `<td></td>
                                 <td><input type="text" data-key="name" placeholder="New Competition"></td>
                                 <td><input type="month" data-key="date"></td>
                                 <td><input type="number" data-key="total" placeholder="0"></td>
                                 <td><input type="url" data-key="link" placeholder="URL"></td>`;
                        break;
                    case 'universities':
                        cells = `<td></td>
                                 <td><input type="text" data-key="name" placeholder="New University"></td>`;
                        break;
                    case 'teams':
                        cells = `<td></td>
                                 <td><input type="text" data-key="name" placeholder="New Team"></td>
                                 <td><input type="text" list="university-list" data-key="university" placeholder="University"></td>
                                 <td><select data-key="members" class="team-members-select" multiple="multiple" style="width: 100%;"></select></td>
                                 <td><input type="checkbox" data-key="isActive" class="is-active-checkbox" checked></td>
                                 <td><input type="month" data-key="createdAt" value="${toYYYYMM(new Date())}"></td>
                                 <td><input type="month" data-key="inactiveAt" class="inactive-at-input" disabled></td>`;
                        break;
                    case 'users':
                        cells = `<td></td>
                                 <td><input type="text" data-key="handle" placeholder="user_handle"></td>
                                 <td><input type="text" data-key="name" placeholder="Full Name"></td>
                                 <td><input type="text" list="university-list" data-key="university" placeholder="University"></td>
                                 <td><input type="checkbox" data-key="isTrusted" checked></td>
                                 <td><input type="month" data-key="updatedAt" value="${toYYYYMM(new Date())}" disabled></td>`;
                        break;
                }
                row.innerHTML = `${cells}<td class="p-2 whitespace-nowrap"><button class="save-btn text-green-600 hover:underline">Save</button> <button class="cancel-btn text-gray-600 hover:underline ml-2">Cancel</button></td>`;
                
                if (editorType === 'teams') {
                    const select = row.querySelector('.team-members-select');
                    userDatabase.forEach(user => {
                        $(select).append(new Option(user.handle, user.handle, false, false));
                    });
                    $(select).select2({ placeholder: "Select members" });

                    const isActiveCheckbox = row.querySelector('.is-active-checkbox');
                    const inactiveAtInput = row.querySelector('.inactive-at-input');
                    isActiveCheckbox.addEventListener('change', (e) => {
                        inactiveAtInput.disabled = e.target.checked;
                        if(e.target.checked) {
                            inactiveAtInput.value = '';
                        }
                    });
                }
            }

            function handleEditorTableEvents(e, editorType) {
                const btn = e.target;
                const row = btn.closest('tr');
                if (!row) return;
                const id = row.dataset.id; // This is the original ID/name/handle

                if (btn.classList.contains('edit-btn')) {
                    const itemData = editorType === 'teams' ? teamDatabase.find(t => t.id === id) : 
                                     editorType === 'users' ? userDatabase.find(u => u.handle === id) : null;

                    row.querySelectorAll('td[data-key]').forEach(td => {
                        const key = td.dataset.key;
                        let value = td.textContent.trim();
                        
                        if (editorType === 'users' && key === 'handle') {
                            td.innerHTML = `<input type="text" data-key="handle" value="${value}" class="bg-gray-200" readonly>`; // Handle is primary key, not editable
                        } else if (key === 'members') {
                            const members = Array.from(td.querySelectorAll('div')).map(div => div.textContent.trim());
                            td.innerHTML = `<select data-key="members" class="team-members-select" multiple="multiple" style="width: 100%;"></select>`;
                            const select = td.querySelector('.team-members-select');
                            userDatabase.forEach(user => {
                                const isSelected = members.includes(user.handle);
                                $(select).append(new Option(user.handle, user.handle, isSelected, isSelected));
                            });
                            $(select).select2({ placeholder: "Select members" }).trigger('change');
                        } else if (key === 'university') {
                            td.innerHTML = `<input type="text" list="university-list" data-key="university" value="${value}">`;
                        } else if (key === 'date' || key === 'inactiveAt' || key === 'createdAt') {
                             td.innerHTML = `<input type="month" data-key="${key}" value="${toYYYYMM(itemData?.[key])}">`;
                             if (key === 'inactiveAt' && editorType === 'teams') {
                                td.querySelector('input').disabled = itemData?.isActive;
                             }
                        } else if (key === 'updatedAt') {
                            td.innerHTML = `<input type="month" data-key="updatedAt" value="${toYYYYMM(itemData?.[key])}" disabled>`;
                        } else if (key === 'link') {
                             td.innerHTML = `<input type="url" data-key="link" value="${td.querySelector('a')?.href || ''}">`;
                        } else if (key === 'isActive' || key === 'isTrusted') {
                            const isChecked = td.querySelector('input').checked;
                            td.innerHTML = `<input type="checkbox" data-key="${key}" class="${key}-checkbox" ${isChecked ? 'checked' : ''}>`;
                        } else {
                            td.innerHTML = `<input type="text" data-key="${key}" value="${value}">`;
                        }
                    });
                    btn.closest('td').innerHTML = `<button class="save-btn text-green-600 hover:underline">Save</button> <button class="cancel-btn text-gray-600 hover:underline ml-2">Cancel</button>`;
                    
                    if (editorType === 'teams') {
                        const isActiveCheckbox = row.querySelector('.isActive-checkbox');
                        const inactiveAtInput = row.querySelector('input[data-key="inactiveAt"]');
                        isActiveCheckbox.addEventListener('change', (e) => {
                            inactiveAtInput.disabled = e.target.checked;
                            if(e.target.checked) {
                                inactiveAtInput.value = '';
                            }
                        });
                    }

                } else if (btn.classList.contains('cancel-btn')) {
                    if (id.startsWith('new_')) {
                        row.remove();
                    } else {
                        renderEditorTable(editorType);
                    }
                } else if (btn.classList.contains('delete-btn')) {
                    showConfirmationModal(`Delete ${capitalize(editorType.slice(0, -1))}?`, `Are you sure you want to delete this entry? This cannot be undone.`, () => {
                        switch (editorType) {
                            case 'competitions': delete competitionDatabase[id]; break;
                            case 'universities': universityDatabase = universityDatabase.filter(name => name !== id); break;
                            case 'teams': teamDatabase = teamDatabase.filter(t => t.id !== id); break;
                            case 'users': userDatabase = userDatabase.filter(u => u.handle !== id); break;
                        }
                        renderAll();
                    });
                } else if (btn.classList.contains('save-btn')) {
                    const data = {};
                    let newId;
                    let isValid = true;
                    
                    row.querySelectorAll('input[data-key], select[data-key]').forEach(input => {
                        const key = input.dataset.key;
                        const value = input.type === 'checkbox' ? input.checked : (input.value || '').trim();
                        
                        if ((key === 'name' || key === 'handle') && !value) {
                            isValid = false;
                            showToast(`${capitalize(key)} cannot be empty.`, 'error');
                        }
                        
                        if (key === 'name' && editorType !== 'users') newId = value;
                        if (key === 'handle' && editorType === 'users') newId = value;

                        if (key === 'members') {
                            data[key] = $(input).val();
                        } else {
                            data[key] = value;
                        }
                    });

                    if (!isValid) return;

                    const performSave = () => {
                        switch (editorType) {
                            case 'competitions':
                                if (id !== newId) delete competitionDatabase[id];
                                competitionDatabase[newId] = { date: data.date, total: parseInt(data.total, 10) || 0, link: data.link };
                                break;
                            case 'universities':
                                if (id.startsWith('new_')) {
                                    if (!universityDatabase.includes(newId)) universityDatabase.push(newId);
                                } else {
                                    const index = universityDatabase.indexOf(id);
                                    if (index > -1) universityDatabase[index] = newId;
                                }
                                universityDatabase.sort();
                                break;
                            case 'teams':
                                const universityName = data.university;
                                if (universityName && !universityDatabase.includes(universityName)) {
                                    universityDatabase.push(universityName);
                                    universityDatabase.sort();
                                }
                                
                                const createdAtDate = data.createdAt ? new Date(data.createdAt).toISOString() : new Date().toISOString();
                                let inactiveAtDate = data.inactiveAt ? new Date(data.inactiveAt).toISOString() : null;

                                if (data.isActive) inactiveAtDate = null;

                                if (inactiveAtDate && new Date(inactiveAtDate) < new Date(createdAtDate)) {
                                    showToast('Inactive date cannot be before the created date.', 'error');
                                    return;
                                }

                                const teamIndex = teamDatabase.findIndex(t => t.id === id);
                                const teamData = {
                                    name: data.name, university: data.university, members: data.members || [],
                                    isActive: data.isActive, createdAt: createdAtDate, inactiveAt: inactiveAtDate
                                };

                                if (teamIndex > -1) {
                                    teamDatabase[teamIndex] = { ...teamDatabase[teamIndex], ...teamData };
                                } else {
                                    teamData.id = crypto.randomUUID();
                                    teamDatabase.push(teamData);
                                }
                                break;
                            case 'users':
                                const isNewUser = id.startsWith('new_');
                                const userIndex = userDatabase.findIndex(u => u.handle === id);

                                if (isNewUser) {
                                    const handleExists = userDatabase.some(u => u.handle.toLowerCase() === data.handle.toLowerCase());
                                    if (handleExists) {
                                        showToast('Error: This handle already exists.', 'error');
                                        return; // Stop save
                                    }
                                }
                                
                                const userData = {
                                    handle: data.handle, name: data.name, university: data.university,
                                    isTrusted: data.isTrusted, updatedAt: new Date().toISOString()
                                };

                                if (userIndex > -1) { // Existing user
                                    userDatabase[userIndex] = { ...userDatabase[userIndex], ...userData };
                                } else { // New user
                                    userData.placements = [];
                                    userDatabase.push(userData);
                                }
                                break;
                        }
                        renderAll();
                    };

                    if (editorType === 'users') {
                        const nameExists = userDatabase.some(u => u.name.toLowerCase() === data.name.toLowerCase() && u.handle.toLowerCase() !== data.handle.toLowerCase());
                        if (nameExists) {
                             showConfirmationModal(
                                'Duplicate Name Warning', 
                                `A user with the name "${data.name}" already exists. Are you sure you want to continue?`,
                                performSave // The actual save logic is the callback
                            );
                        } else {
                            performSave(); // No duplicate name, save directly
                        }
                    } else {
                        performSave(); // For other types, save directly
                    }
                }
            }

            function downloadEditorCSV(editorType) {
                let rows = [];
                let fileNameSuffix = '';
                switch (editorType) {
                    case 'competitions':
                        rows.push(['Competition Name', 'Date (YYYY-MM)', 'Total Participants', 'Link']);
                        Object.entries(competitionDatabase).forEach(([name, data]) => {
                            rows.push([name, data.date, data.total, data.link]);
                        });
                        fileNameSuffix = 'competitions';
                        break;
                    case 'universities':
                        rows.push(['University Name']);
                        universityDatabase.forEach(name => rows.push([name]));
                        fileNameSuffix = 'universities';
                        break;
                    case 'teams':
                        rows.push(['Team Name', 'University', 'Members', 'Is Active', 'Created At', 'Inactive At']);
                        teamDatabase.forEach(team => {
                            rows.push([`"${team.name}"`, `"${team.university}"`, `"${team.members.join(',')}"`, team.isActive, new Date(team.createdAt).toISOString(), team.inactiveAt ? new Date(team.inactiveAt).toISOString() : '']);
                        });
                        fileNameSuffix = 'teams';
                        break;
                    case 'users':
                        rows.push(['Handle', 'Name', 'University', 'Is Trusted']);
                        userDatabase.forEach(user => {
                           rows.push([user.handle, user.name, user.university, user.isTrusted]);
                        });
                        fileNameSuffix = 'users';
                        break;
                }
                const csvString = rows.map(e => e.map(cell => typeof cell === 'string' && cell.includes(',') ? `"${cell}"` : cell).join(",")).join("\n");
                downloadFile(csvString, `${fileNameSuffix}_export_${getFormattedDateTimeString()}.csv`, 'text/csv;charset=utf-8;')
            }

            function handleDeleteSelected(editorType) {
                const table = document.getElementById(`${editorType}EditorTable`);
                const selectedCheckboxes = table.querySelectorAll('.editor-select-checkbox:checked');
                if (selectedCheckboxes.length === 0) {
                    showToast('No items selected to delete.', 'error');
                    return;
                }

                const idsToDelete = Array.from(selectedCheckboxes).map(cb => cb.dataset.id);

                showConfirmationModal(`Delete ${selectedCheckboxes.length} items?`, 'This action is permanent and cannot be undone.', () => {
                    let deletedCount = 0;
                    switch (editorType) {
                        case 'competitions':
                            idsToDelete.forEach(id => { if(competitionDatabase[id]) { delete competitionDatabase[id]; deletedCount++; } });
                            break;
                        case 'universities':
                            const initialLengthUni = universityDatabase.length;
                            universityDatabase = universityDatabase.filter(name => !idsToDelete.includes(name));
                            deletedCount = initialLengthUni - universityDatabase.length;
                            break;
                        case 'teams':
                            const initialLengthTeam = teamDatabase.length;
                            teamDatabase = teamDatabase.filter(t => !idsToDelete.includes(t.id));
                            deletedCount = initialLengthTeam - teamDatabase.length;
                            break;
                        case 'users':
                            const initialLengthUser = userDatabase.length;
                            userDatabase = userDatabase.filter(u => !idsToDelete.includes(u.handle));
                            deletedCount = initialLengthUser - userDatabase.length;
                            break;
                    }
                    showToast(`${deletedCount} items deleted.`, 'info');
                    renderAll();
                });
            }

            function attachEditorTableEventListeners(editorType) {
                const editorContentDiv = document.querySelector(`[data-editor-type="${editorType}"]`);
                if(!editorContentDiv) return;

                editorContentDiv.addEventListener('click', e => {
                    const targetId = e.target.id;
                    
                    if (targetId === `add${capitalize(editorType)}RowBtn`) {
                        addEditorTableRow(editorType);
                    } else if (targetId === `deleteSelected${capitalize(editorType)}Btn`) {
                        handleDeleteSelected(editorType);
                    } else if (targetId === `download${capitalize(editorType)}CsvEditor`) {
                        downloadEditorCSV(editorType);
                    } else if (e.target.closest('.sortable-header')) {
                        const header = e.target.closest('.sortable-header');
                        const key = header.dataset.sortKey;
                        let direction = 'desc';
                        if (editorSortStates[editorType].key === key) {
                            direction = editorSortStates[editorType].direction === 'desc' ? 'asc' : 'desc';
                        }
                        editorSortStates[editorType] = { key, direction };
                        renderEditorTable(editorType);
                    } else if (e.target.matches('.save-btn, .cancel-btn, .edit-btn, .delete-btn')) {
                        handleEditorTableEvents(e, editorType);
                    }
                });
                
                editorContentDiv.addEventListener('change', e => {
                    const target = e.target;
                    const editorTable = editorContentDiv.querySelector('.editor-table');
                    if (target.matches('.select-all-editor-checkbox')) {
                        editorTable.querySelectorAll('tbody .editor-select-checkbox').forEach(cb => {
                            cb.checked = target.checked;
                        });
                    } else if(target.matches('.editor-select-checkbox')) {
                        updateSelectAllState(editorTable);
                    } else if (target.id === `upload${capitalize(editorType)}CsvEditor`) {
                         const handlers = { competitions: handleCompetitionUpload, universities: handleUniversityUpload, teams: handleTeamUpload, users: handleUserUpload };
                         handleFileUpload(target.files[0], handlers[editorType]); 
                         target.value = '';
                    }
                });

                editorContentDiv.addEventListener('keyup', e => {
                    if (e.target.matches('input[data-filter-key]')) {
                        editorFilters[editorType][e.target.dataset.filterKey] = e.target.value;
                        renderEditorTable(editorType);
                    }
                });
            }

            function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

            function populateUniversityDatalist() {
                const allUnis = new Set(universityDatabase);
                userDatabase.forEach(u => { if(u.university) allUnis.add(u.university) });
                teamDatabase.forEach(t => { if(t.university) allUnis.add(t.university) });
                universityDatabase = Array.from(allUnis).sort();

                universityDataList.innerHTML = '';
                universityDatabase.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    universityDataList.appendChild(option);
                });
            }

            function updateEditorSortIndicators(editorType) { 
                const table = document.getElementById(`${editorType}EditorTable`); 
                if (!table) return; 
                table.querySelectorAll('th.sortable-header').forEach(th => { 
                    th.classList.remove('sort-asc', 'sort-desc'); 
                    if (th.dataset.sortKey === editorSortStates[editorType].key) {
                        th.classList.add(`sort-${editorSortStates[editorType].direction}`);
                    }
                    th.querySelector('.sort-icon').textContent = editorSortStates[editorType].direction === 'asc' ? '' : ''; 
                }); 
            }
            
            function getFormattedDateTimeString() { const now = new Date(); const pad = (num) => num.toString().padStart(2, '0'); return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}`; }
            
            function downloadFile(content, fileName, mimeType) { const blob = new Blob([content], { type: mimeType }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = fileName; document.body.appendChild(link); link.click(); document.body.removeChild(link); }
            
            function showTeamDetailsModal(teamId) {
                const team = teamDatabase.find(t => t.id === teamId);
                if (!team) {
                    showToast('Team not found.', 'error');
                    return;
                }

                const teamPlacements = userDatabase
                    .flatMap(u => u.placements.filter(p => p.teamId === team.id))
                    .reduce((acc, p) => {
                        if (!acc.some(ap => ap.name === p.name)) acc.push(p);
                        return acc;
                    }, [])
                    .sort((a, b) => (competitionDatabase[b.name]?.date || '').localeCompare(competitionDatabase[a.name]?.date || ''));

                let content = `
                    <h2 class="text-3xl font-bold text-teal-800 mb-2">${team.name}</h2>
                    <p class="text-lg text-gray-600 mb-1">${team.university}</p>
                    <p class="text-sm text-gray-500">Created: ${formatMonthYear(team.createdAt)} ${team.inactiveAt ? `| Inactive since: ${formatMonthYear(team.inactiveAt)}` : ''}</p>
                    <hr class="my-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-xl font-semibold mb-3">Members (${team.members.length})</h3>
                            <div class="space-y-2">
                                ${team.members.map(m => `<div class="p-2 bg-gray-50 rounded text-sm">${createUserLink(m)}</div>`).join('')}
                            </div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold mb-3">Team Competitions (${teamPlacements.length})</h3>
                            <div class="space-y-2 max-h-60 overflow-y-auto pr-2">
                                ${teamPlacements.length > 0 ? teamPlacements.map(p => `
                                    <div class="p-2 bg-gray-50 rounded text-sm">
                                        <span class="font-medium">${createCompetitionLink(p.name)}</span> - Rank ${p.rank}/${p.total}
                                    </div>
                                `).join('') : '<p class="text-gray-500 text-sm">No competitions recorded.</p>'}
                            </div>
                        </div>
                    </div>
                `;
                modalContentContainer.innerHTML = content;
                detailsModal.classList.remove('hidden');
            }

            function hideModal() { 
                detailsModal.classList.add('hidden'); 
            }

            function createUserLink(handle) {
                // In the editor, we don't need a link, just the text.
                return handle || 'N/A';
            }

            function createTeamLink(teamName, teamId) {
                return `<button class="team-link" data-team-id="${teamId}">${teamName}</button>`;
            }

            function createCompetitionLink(compName) {
                const comp = competitionDatabase[compName];
                if (comp && comp.link) {
                    return `<a href="${comp.link}" target="_blank" class="competition-link">${compName}</a>`;
                }
                return compName;
            }
            
            function updateSelectAllState(tableElement) {
                if (!tableElement) return;
                const headCheckbox = tableElement.querySelector('thead input[type="checkbox"]');
                const bodyCheckboxes = tableElement.querySelectorAll('tbody input[type="checkbox"]');
                const total = bodyCheckboxes.length;
                const checkedCount = Array.from(bodyCheckboxes).filter(cb => cb.checked).length;
                
                if (headCheckbox) {
                    headCheckbox.checked = total > 0 && total === checkedCount;
                }
            }
            
            // --- EVENT LISTENERS ---
            appContainer.addEventListener('click', (e) => {
                const teamLink = e.target.closest('.team-link');
                if (teamLink) {
                    e.preventDefault();
                    showTeamDetailsModal(teamLink.dataset.teamId);
                }
            });

            tabContentEditors.addEventListener('click', e => {
                if(e.target.matches('.editor-tab-btn')){
                     document.querySelectorAll('.editor-tab-btn').forEach(btn => {
                        btn.classList.remove('active', 'bg-blue-600', 'text-white');
                        btn.classList.add('text-gray-600');
                     });
                     e.target.classList.add('active', 'bg-blue-600', 'text-white');
                     e.target.classList.remove('text-gray-600');
                     renderCurrentEditorView();
                }
            });

            closeModalBtn.addEventListener('click', hideModal);
            detailsModal.addEventListener('click', (e) => { 
                if (e.target === detailsModal) hideModal();
            });

            confirmCancelBtn.addEventListener('click', hideConfirmationModal);
            confirmOkBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); hideConfirmationModal(); });
            
            passwordForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const password = passwordField.value;
                if (confirmPasswordField.required && password !== confirmPasswordField.value) {
                    showToast("Passwords do not match.", "error");
                    return;
                }
                if (passwordCallback) {
                    passwordCallback(password);
                }
                hidePasswordModal();
            });
            passwordCancelBtn.addEventListener('click', hidePasswordModal);

            jsonFileInput.addEventListener('change', (e) => { loadJsonFile(e.target.files[0]); e.target.value = ''; });
            downloadDbFullBackupBtn.addEventListener('click', downloadDbFullBackup);
            
            // --- LOCAL STORAGE PERSISTENCE ---
            function saveDataToLocalStorage() {
                try {
                    const dataToSave = {
                        users: userDatabase,
                        teams: teamDatabase,
                        competitions: competitionDatabase,
                        universities: universityDatabase,
                        version: 'v19' // Incremented version
                    };
                    localStorage.setItem('electiToolData_v19', JSON.stringify(dataToSave));
                } catch (e) {
                    console.error("Could not save to localStorage. Data might be too large.", e);
                    showToast("Error: Could not save data. It might be too large for your browser's local storage.", "error", 5000);
                }
            }

            function loadDataFromLocalStorage() {
                const savedData = localStorage.getItem('electiToolData_v19');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        userDatabase = data.users.map(u => ({...u, isTrusted: u.isTrusted !== false, updatedAt: new Date(u.updatedAt) })) || [];
                        teamDatabase = data.teams || [];
                        competitionDatabase = data.competitions || {};
                        universityDatabase = data.universities || [];
                    } catch (e) {
                        console.error("Error parsing data from localStorage", e);
                        userDatabase = []; teamDatabase = []; competitionDatabase = {}; universityDatabase = [];
                    }
                }
            }

            window.addEventListener('beforeunload', saveDataToLocalStorage);

            function initializeApp() {
                loadDataFromLocalStorage();
                renderAll();
            }

            initializeApp();
        });
    </script>
</body>
</html>

